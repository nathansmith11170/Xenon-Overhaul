<?xml version='1.0' encoding='utf-8'?>
<mdscript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="GM_FindObject" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>
    <!--Base Mission information-->
    <!--
      Generic Mission name:    Find object in specified space - intended for Master Missions
      Primary 'missiontype':   missiontype.find
      Page: 30149
    -->
    <!--
      The Feedback Manager contains a table of feedback values related to this Generic Mission. 
		  This table is 'const' during the mission (the table itself doesn't change anymore after inialization)
	    There are several maintypes of feedback:
        event:    Something which happens during a mission but does not cause it to end e.g. the mission being accepted
        removed:  The mission offer was removed before acceptance
        success:  The mission was successfully completed by the player
        failure:  The player failed the mission
        error:    Something went wrong with the mission set-up or during the mission
    -->
    <cue name="FeedbackValueManager" namespace="this" version="4">
      <actions>
        <set_value name="$FeedbackValues" exact="table[                    $MISSION_GENERATED       = table[$type = 'event',    $text = 'Mission variation generated successfully'],                    $MISSION_ACCEPTED        = table[$type = 'event',    $text = 'Mission accepted'],                    $MISSION_NO_VARIANT      = table[$type = 'event',    $text = 'No mission variant currently possible'],                                        $OFFER_REMOVED           = table[$type = 'removed',  $text = 'Offer removed'],                    $DECLINED_OFFER          = table[$type = 'removed',  $text = 'Player declined Event Offer'],                    $EVENT_OFFER_TIMEOUT     = table[$type = 'removed',  $text = 'Event Offer timeout'],                    $SIGNAL_LEAK_REMOVED     = table[$type = 'removed',  $text = 'Signal leak offer removed'],                    $DELIVERYNPC_KILLED      = table[$type = 'removed',  $text = 'Delivery NPC was killed'],                    $DELIVERY_OBJECT_DESTROYED = table[$type = 'removed',  $text = 'Deliver object destroyed'],                                        $MISSION_SUCCEEDED       = table[$type = 'success',  $text = 'Mission succeeded'],                                        $MISSION_ABORTED         = table[$type = 'failure',  $text = 'Mission aborted by player'],                    $FORCED_CLEANUP          = table[$type = 'failure',  $text = 'Forced to end from outside'],                    $MISSION_TIMEOUT         = table[$type = 'failure',  $text = 'Mission timeout'],                    $RML_FAILED              = table[$type = 'failure',  $text = 'RML failure'],                                        $NO_VALID_CLIENT_OWNER   = table[$type = 'error',    $text = 'No valid ClientOwner parameter provided'],                    $INVALID_OFFER_TYPE      = table[$type = 'error',    $text = 'No offer parameters were valid'],                    $NO_TEXT_OFFSET          = table[$type = 'error',    $text = 'No TextOffset set'],                    $INVALID_FACTION_PARAM   = table[$type = 'error',    $text = 'Invalid Faction param'],                    $INVALID_TARGETOBJ_PARAM = table[$type = 'error',    $text = 'Invalid targetobjects param'],                    $INVALID_FORCE_CLEANUP   = table[$type = 'error',    $text = 'ForceCleanup cue invalid'],                    $RML_ERROR               = table[$type = 'error',    $text = 'RML error']                    ]"/>
      </actions>
      <patch sinceversion="4">
        <!--To patch new feedback values, increment 'version' and 'sinceversion' number-->
        <force_cue cue="FeedbackValueManager"/>
      </patch>
    </cue>
    <!--Required variables: $Page & $TextOffset (and any below substitute_text values)
    If text is to be substituted for a new text variant, people should feel free to add the substitution below. Alternatively, pass in an overriding text in the $TextTable param-->
    <library name="GenerateTextTable">
      <actions>
        <!--Text page indexes $TextOffset + #
        1 = $TextTable.$missionname
        2 = $TextTable.$description
        3 = $TextTable.$objective_find      Objective text during 'Find: ' objective
        4 = $TextTable.$objective_pickup    Objective text during 'Pickup: ' objective
        5 = $TextTable.$offer_collect       Objective text for 'Collect: ' and 'Deliver: ' offer
        6 = $TextTable.$conversationoption  Used to substitute current amount and warename. Table value only used for substitution. example: "Deliver: $AMOUNT$x $WARE$"
        7 = $TextTable.$tooltip             Conversation option tooltip if not selectable
        -->
        <set_value name="$TextTable.$missionname" exact="readtext.{$Page}.{$TextOffset + 1}" chance="if $TextTable.$missionname? then 0 else 100"/>
        <set_value name="$TextTable.$description" exact="readtext.{$Page}.{$TextOffset + 2}" chance="if $TextTable.$description? then 0 else 100"/>
        <set_value name="$TextTable.$objective_find" exact="readtext.{$Page}.{$TextOffset + 3}" chance="if $TextTable.$objective_find? then 0 else 100"/>
        <set_value name="$TextTable.$objective_pickup" exact="readtext.{$Page}.{$TextOffset +4}" chance="if $TextTable.$objective_pickup? then 0 else 100"/>
        <set_value name="$TextTable.$offer_collect" exact="readtext.{$Page}.{$TextOffset + 5}" chance="if $TextTable.$offer_collect? then 0 else 100"/>
        <do_if value="$DeliveryNPC">
          <set_value name="$TextTable.$conversationoption" exact="readtext.{$Page}.{$TextOffset + 6}" chance="if $TextTable.$conversationoption? then 0 else 100"/>
          <set_value name="$TextTable.$tooltip" exact="readtext.{$Page}.{$TextOffset + 7}" chance="if $TextTable.$tooltip? then 0 else 100"/>
        </do_if>
        <run_actions ref="md.LIB_Generic.GenerateTextTable_BriefingWarning_Call" result="$TextTable.$description">
          <param name="BriefingText" value="$TextTable.$description"/>
          <param name="TargetSpace" value="$TargetSector"/>
        </run_actions>
      </actions>
    </library>
    <library name="GenerateVoiceTable">
      <actions>
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </actions>
    </library>
    <library name="Start" version="4">
      <params>
        <!-- Generic Parameters -->
        <param name="OfferObject" default="null" comment="The object on which this mission is based e.g. A Ship / Station / Signal Leak. Only needed for missions with a physical location."/>
        <param name="Client" default="null" comment="Pre-existing client"/>
        <param name="ClientOwner" default="null" comment="Overriding owner for reward calculation or creation of $Client if not provided. Defaults to $OfferObject owner if able"/>
        <param name="MissionCue" default="null" comment="Cue the mission is attached to. Defaults to Start (this)."/>
        <param name="MissionThread" default="null" comment="Mission thread for the offer and mission"/>
        <param name="GenerateReward" default="true" comment="If RewardCr or RewardNotoriety are invalid, generate them?"/>
        <param name="RewardCr" default="null" comment="If the reward for this mission is credits, the number of credits should be set to this variable."/>
        <param name="RewardObj" default="null" comment="If the reward for this mission is not credits, and is an object, it should be set to this variable."/>
        <param name="RewardNotoriety" default="null"/>
        <param name="RewardText" default="null" comment="Any text needed to define the reward for this mission - may be used in conjunction with $RewardCr and $RewardObj."/>
        <param name="MissionDuration" default="null"/>
        <param name="MissionType" default="missiontype.find" comment="Variations can override mission type if required"/>
        <param name="MissionLevel"/>
        <param name="Difficulty"/>
        <!--Offer location and conversation-->
        <param name="WithoutOffer" default="false" comment="Do not create a mission offer. Either run immediatly or wait for WithoutOfferWaitCue"/>
        <param name="WithoutOfferWaitCue" default="null" comment="Do not create a mission offer but wait for this cue to be completed before running the mission"/>
        <param name="DeclineButton" default="true" comment="Have a decline button instead of a back button in the offer conversation"/>
        <param name="EventOffer" default="false" comment="Is the mission offered directly to the player with an interactive event"/>
        <param name="ConversationOffer" default="false" comment="When $EventOffer is false, should this offer be through a conversation with the $Client. Otherwise, offer at mission location"/>
        <param name="ConversationTriggerCue" default="null" comment="If provided, when this cue is signalled, start the mission offer conversation."/>
        <param name="OfferMaxDistance" default="null"/>
        <param name="HideFromBBS" default="false" comment="Hide this offer from the BBS? Show only through locations or special conversation handling."/>
        <param name="RemoveOnSectorChange" default="true"/>
        <param name="OfferDistance" default="50km" comment="Distance to the offer location before it becomes visible on the map or BBS (unless otherwise hidden)"/>
        <!--BBS only params-->
        <param name="BBSObject" default="null"/>
        <param name="BBSDistance" default="null"/>
        <param name="BBSTimeoutMin" default="null"/>
        <param name="BBSTimeoutMax" default="null"/>
        <param name="BBSSpace" default="null"/>
        <!--Mission text-->
        <param name="Page" comment="Allows a different text page to be used instead of the generic one. Text IDs must be mapped similarly."/>
        <param name="TextOffset" comment="The text offset for this variant's text on the page.                Each variant starts at a different offset, but the entries[] within that offset have to match for all variants."/>
        <param name="TextTable" default="table[]" comment="Table, usually populated by the mission, to store the texts by an identifier key e.g. $missionname = 'Kill Bala Gi'                Check library 'GenerateTextTable' for identifier keys. Pass in a table with such an entry to override the text usually generated from the $Page and $TextOffset"/>
        <param name="VoiceTable" default="table[]" comment="Table, usually populated by the mission, keys can have a value of 0 (=stay silent)"/>
        <!-- Optional mission setup overrides -->
        <param name="Faction" comment="The faction which asked us to find the object"/>
        <param name="TargetSector" comment=""/>
        <param name="TargetOffset" comment=""/>
        <param name="TargetRadius" comment="radius"/>
        <param name="TargetObjects" comment=""/>
        <!--Delivery params-->
        <param name="DeliveryNPC" default="null" comment="The NPC to which the items should be delivered. If null, the mission ends on collecting the ware (primarily for legacy mission support)"/>
        <!-- ************************************************************************************************************************************************************************ -->
        <!-- If the mission is to manage placing the delivery NPC, $DeliveryObject must be set.
        Interior parameters are optional but if one is set, they must be passed in together -->
        <param name="PlaceNPC" default="false" comment="Does the mission handle the placement and removal of the delivery NPC? If false, some other system must be in charge of doing so."/>
        <param name="PlacementTable" default="table[$cue = namespace, $priority = 50]" comment="Table containing the owning cue and priority of placing the NPC vs other missions"/>
        <param name="DeliveryObject" default="null" comment="The object in which to place the NPC or to place the dynamic interior"/>
        <param name="DeliveryNPCSlotTags" default="[tag.npc_generic]" comment="NPC slot tags to help position the DeliveryNPC"/>
        <!-- Interior parameters: Room, corridor and door definitions could be provided by the caller through get_room_definition -->
        <param name="DeliveryRoomMacro" default="null" comment="The dynamic interior room the DeliveryNPC should be placed in, if not placed already"/>
        <param name="DeliveryCorridorMacro" default="null" comment="The dynamic interior corridor leading to DeliveryRoomMacro"/>
        <param name="DeliveryDoors" default="null" comment="The possible dynamic interior doors used to connect the room and corridor. When defining a room or corridor macro, this is is the variable saved in the doors parameter"/>
        <param name="DeliveryInteriorName" default="null" comment="The name of the dynamic interior the DeliveryNPC should used, if not placed already"/>
        <!-- ************************************************************************************************************************************************************************ -->
        <param name="ReportActivateCue" default="null" comment="Cue to signal when the Activate-cue is signalled, for creating of crates"/>
        <param name="ReportSignalCue" default="null" comment="Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue"/>
        <param name="CancelOfferCue" default="null" comment="Cue which when completed will force this missions offer to be removed and cleaned up. No effect if mission has been accepted."/>
        <param name="ForceCleanup" default="null" comment="Cue to force a cleanup from outside when completed"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <!--Feedback value setup-->
        <set_value name="$Feedback" exact="null"/>
        <set_value name="$FeedbackManager" exact="md.GM_FindObject.FeedbackValueManager"/>
        <assert value="$WithoutOffer or not $MissionCue or (not $MissionCue.hasmission and not $MissionCue.hasmissionoffer)" text="'Mission is set to create an offer but provided MissionCue: ' + $MissionCue + ' already has an offer or is a running mission [Owen]'"/>
        <!--Param validation-->
        <do_if value="not $WithoutOffer">
          <!--Optional variables (at least one should exist): $OfferObject, (bool)$HideFromBBS, (bool)$ConversationOffer, (bool)$EventOffer
          Result variables:
          $OfferType = 'signalleak' OR 'objectbased' OR 'eventoffer' OR 'conversationoffer'
          $AllowOfferEvent = Will an event offering this event be also fired immediatly?-->
          <include_actions ref="md.GenericMissions.GetOfferType"/>
          <do_if value="not $OfferType">
            <set_value name="$Feedback" exact="'$INVALID_OFFER_TYPE'"/>
          </do_if>
        </do_if>
        <do_if value="not $Feedback">
          <do_if value="not $TextOffset">
            <set_value name="$Feedback" exact="'$NO_TEXT_OFFSET'"/>
          </do_if>
          <do_else>
            <do_if value="$Client">
              <set_value name="$PreexistingClient"/>
            </do_if>
            <do_if value="not $ClientOwner">
              <set_value name="$ClientOwner" exact="if $Client then $Client.owner else @$OfferObject.owner"/>
              <assert value="$ClientOwner" text="'No valid $ClientOwner [Owen]'"/>
            </do_if>
            <do_if value="not $ClientOwner">
              <set_value name="$Feedback" exact="'$NO_VALID_CLIENT_OWNER'"/>
            </do_if>
            <do_else>
              <!--Mission specific param checks-->
              <do_if value="typeof $Faction != datatype.faction">
                <set_value name="$Feedback" exact="'$INVALID_FACTION_PARAM'"/>
              </do_if>
              <do_if value="$ReportActivateCue and $TargetObjects.count">
                <set_value name="$Feedback" exact="'$INVALID_TARGETOBJ_PARAM'" comment="If activate-cue is set, $TargetObjects.count should be 0"/>
              </do_if>
              <do_elseif value="not $ReportActivateCue and not $TargetObjects.count">
                <set_value name="$Feedback" exact="'$INVALID_TARGETOBJ_PARAM'" comment="If activate-cue is not set, $TargetObjects should be non-zero"/>
              </do_elseif>
            </do_else>
          </do_else>
        </do_if>
      </actions>
      <patch sinceversion="2" state="complete">
        <set_value name="$DeliveryNPC" exact="null"/>
        <set_value name="$DeliveryObject" exact="null"/>
      </patch>
      <patch sinceversion="3" state="complete">
        <set_value name="$PlacementTable" exact="table[$cue = namespace, $priority = 50]"/>
        <set_value name="$DeliveryNPCSlotTags" exact="[tag.npc_generic]"/>
        <remove_value name="$DeliveryNPCSlot"/>
      </patch>
      <patch sinceversion="4">
        <set_value name="$VoiceTable" exact="table[]"/>
        <run_actions ref="md.LIB_Generic.GenerateGenericVoiceTable" result="$VoiceTable">
          <param name="VoiceTable" value="$VoiceTable"/>
        </run_actions>
      </patch>
      <cues>
        <cue name="Do_Not_Start_Mission" onfail="cancel">
          <conditions>
            <check_value value="$Feedback"/>
          </conditions>
          <actions>
            <signal_cue cue="CleanUp"/>
          </actions>
        </cue>
        <cue name="Do_Start_Mission" onfail="cancel" version="2">
          <conditions>
            <check_value value="not $Feedback"/>
          </conditions>
          <actions>
            <do_if value="not $MissionCue">
              <set_value name="$MissionCue" exact="Start"/>
            </do_if>
            <do_if value="not $PreexistingClient?">
              <!-- No pre-existing client, create a temporary client for this mission -->
              <!-- This auto-assigns a 'matching' text-page using the metadata (id=0) specified in the text-files. Speak commands for this actor will then refer to the selected text-page-->
              <!-- Possibly we'll need to add additional filters (in case some topics aren't supported by all generic text-pages) -->
              <create_cue_actor cue="Start" name="$Client" comment="temporary cue-actor will be cleaned up in the Cleanup-cue, see destroy_object on $Client">
                <select faction="$ClientOwner"/>
                <owner exact="$ClientOwner"/>
              </create_cue_actor>
            </do_if>
            <!-- Determine the reward (credits/object/notoriety) -->
            <do_if value="$GenerateReward">
              <include_actions ref="md.LIB_Reward_Balancing.Allocate_RewardWeight" comment="input: $Difficulty, $ClientOwner; output: $RewardCreditsWeight, $RewardModWeight, $RewardSeminarWeight"/>
              <do_if value="not $RewardCr" weight="$RewardCreditsWeight">
                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Money" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]" comment="basic reward credits"/>
                <include_actions ref="md.LIB_Reward_Balancing.Apply_RewardMultiplier" comment="signal leak and mission thread bonus"/>
                <set_value name="$RewardCr" exact="$Reward_Money__Result_Multiplied"/>
              </do_if>
              <do_if value="not $RewardObj">
                <run_actions ref="md.LIB_Reward_Balancing.DetermineAdditionalReward" result="$AdditionalReward">
                  <param name="RewardModWeight" value="$RewardModWeight"/>
                  <param name="RewardSeminarWeight" value="$RewardSeminarWeight"/>
                </run_actions>
                <do_if value="$AdditionalReward != null">
                  <set_value name="$RewardObj" exact="$AdditionalReward"/>
                  <set_value name="$RewardText" exact="$RewardObj.name"/>
                </do_if>
              </do_if>
              <do_if value="not $RewardNotoriety">
                <signal_cue_instantly cue="md.LIB_Reward_Balancing.Reward_Notoriety" param="[Start, $Difficulty, $MissionLevel, $ClientOwner]"/>
                <set_value name="$RewardNotoriety" exact="$Reward_Notoriety__Result"/>
              </do_if>
            </do_if>
            <include_actions ref="GenerateTextTable"/>
            <include_actions ref="GenerateVoiceTable"/>
            <do_if value="$ReportSignalCue">
              <!--Signal the $ReportSignalCue that the mission has been successfully generated-->
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_GENERATED.clone"/>
              <set_value name="$FeedbackData.$ID" exact="'$MISSION_GENERATED'"/>
              <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission variation generated successfully"/>
              <signal_cue_instantly cue="$ReportSignalCue" param="table[$Name = $TextTable.$missionname, $Cue = $MissionCue, $Reward = $RewardCr, $RewardText = $RewardText]"/>
            </do_if>
          </actions>
          <cues>
            <!--***MISSION OFFER***-->
            <cue name="With_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer" exact="false"/>
              </conditions>
              <cues>
                <!--Cue which creates the offer, when signalled. To be signalled from the GenericMissions.OfferMission library, referenced below-->
                <cue name="CreateOffer" instantiate="true" comment="instanced to prevent cleanup">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @$OfferCreated"/>
                  </conditions>
                  <actions>
                    <do_if value="not @$OfferCreated">
                      <!-- Briefing details -->
                      <create_offer cue="$MissionCue" location="$OfferObject" distance="$OfferDistance" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" actor="$Client" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText" duration="$MissionDuration" hidden="$HideFromBBS" space="$BBSSpace">
                        <briefing comment="duplicated, see MissionAccepted!">
                          <objective step="1" action="objective.find" text="$TextTable.$objective_find"/>
                          <objective step="2" action="objective.collect" text="$TextTable.$offer_collect"/>
                          <objective step="if $DeliveryNPC then 3 else 2" action="if $DeliveryNPC then objective.deliver else objective.collect" text="$TextTable.$offer_collect"/>
                        </briefing>
                      </create_offer>
                    </do_if>
                    <set_value name="$OfferCreated" exact="true"/>
                  </actions>
                </cue>
                <!--The majority of the offer logic is within this library. The parameters we pass down below, specify in which way this mission is going to be offered to the player (i.e. BBS, Signal-Leak, ...)
                Some of the mission specific handling is still contained in this file but triggered via the library via a signal e.g. setting up the briefing details via the 'CreateOffer' cue above.-->
                <cue name="Offer_Management" ref="md.GenericMissions.OfferMission">
                  <param name="OfferType" value="$OfferType"/>
                  <param name="OfferCue" value="$MissionCue"/>
                  <param name="CleanupCue" value="Offer_End"/>
                  <param name="BriefingSetupCue" value="CreateOffer"/>
                  <param name="MissionName" value="$TextTable.$missionname"/>
                  <param name="CancelOfferCue" value="$CancelOfferCue"/>
                  <!--Object based params (offered by Station/Ship/Signal-leak)-->
                  <param name="TimeoutMin" value="8min" comment="Minimum time the offer remains valid"/>
                  <param name="TimeoutMax" value="12min"/>
                  <param name="MaxDistance" value="$OfferMaxDistance"/>
                  <param name="RemoveOnSectorChange" value="$RemoveOnSectorChange"/>
                  <!--Object and Signal Leak based params-->
                  <param name="OfferObject" value="$OfferObject"/>
                  <!--BBS based offers-->
                  <param name="BBSObject" value="@$BBSObject"/>
                  <param name="BBSDistance" value="@$BBSDistance"/>
                  <param name="BBSTimeoutMin" value="@$BBSTimeoutMin"/>
                  <param name="BBSTimeoutMax" value="@$BBSTimeoutMax"/>
                  <!--Conversation event offers-->
                  <param name="AllowOfferEvent" value="$AllowOfferEvent"/>
                  <param name="ConversationTriggerCue" value="$ConversationTriggerCue"/>
                  <!--Client-->
                  <param name="Client" value="$Client"/>
                  <param name="Line_EventOffer" value="1000101" comment="Client speaks this line from his generic-npc-page"/>
                  <param name="Line_StartConversation" value="null" comment="Client speaks this line from his generic-npc-page"/>
                  <param name="Line_Goodbye" value="null" comment="Client speaks this line from his generic-npc-page"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>
                <!--Cue signalled when the offer library is finished-->
                <cue name="Offer_End">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <do_if value="this.$Feedback.$ID == '$accepted_offer'">
                      <signal_cue cue="MissionAccepted"/>
                    </do_if>
                    <do_elseif value="this.$Feedback.$ID == '$DECLINED_OFFER'">
                      <set_value name="$Feedback" exact="'$DECLINED_OFFER'"/>
                      <signal_cue cue="CleanUp"/>
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$OFFER_REMOVED'">
                      <set_value name="$Feedback" exact="'$OFFER_REMOVED'"/>
                      <signal_cue cue="CleanUp"/>
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$SIGNAL_LEAK_REMOVED'">
                      <set_value name="$Feedback" exact="'$SIGNAL_LEAK_REMOVED'"/>
                      <signal_cue cue="CleanUp"/>
                    </do_elseif>
                    <do_elseif value="this.$Feedback.$ID == '$EVENT_OFFER_TIMEOUT'">
                      <set_value name="$Feedback" exact="'$EVENT_OFFER_TIMEOUT'"/>
                      <signal_cue cue="CleanUp"/>
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>
            <!--These cues handle the cases where a mission is automatically accepted on creation-->
            <cue name="Without_Offer" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="not $WithoutOfferWaitCue"/>
              </conditions>
              <actions>
                <signal_cue cue="MissionAccepted"/>
              </actions>
            </cue>
            <cue name="Without_Offer_Wait_Cue" onfail="cancel">
              <conditions>
                <check_value value="$WithoutOffer"/>
                <check_value value="$WithoutOfferWaitCue"/>
              </conditions>
              <cues>
                <cue name="Without_Offer_Wait_Cue_Completed">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="$WithoutOfferWaitCue"/>
                      <check_all>
                        <event_cue_signalled cue="$WithoutOfferWaitCue"/>
                        <check_value value="event.param == $MissionCue"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="MissionAccepted"/>
                  </actions>
                </cue>
              </cues>
            </cue>
            <cue name="DeliverNPCDestroyed_Early_Check" onfail="cancel">
              <conditions>
                <check_value value="$DeliveryNPC"/>
              </conditions>
              <cues>
                <cue name="DeliverNPCDestroyed_Early">
                  <conditions>
                    <event_object_destroyed object="$DeliveryNPC"/>
                  </conditions>
                  <actions>
                    <set_value name="$Feedback" exact="'$DELIVERYNPC_KILLED'"/>
                    <signal_cue cue="CleanUp"/>
                  </actions>
                </cue>
              </cues>
            </cue>
            <cue name="DeliverStationDestroyed_Early_Check" onfail="cancel">
              <conditions>
                <check_value value="$DeliveryObject"/>
              </conditions>
              <cues>
                <cue name="DeliverStationDestroyed_Early">
                  <conditions>
                    <event_object_destroyed object="$DeliveryObject"/>
                  </conditions>
                  <actions>
                    <set_value name="$Feedback" exact="'$DELIVERY_OBJECT_DESTROYED'"/>
                    <signal_cue cue="CleanUp"/>
                  </actions>
                </cue>
              </cues>
            </cue>
            <!--These cues handle the briefing presentations e.g. Holomap or cutscene render targets (depending on the mission)
            note: play_cutscene action should not be in the actions of the cue with a event_briefing_submission_selected condition. It must be delayed-->
            <cue name="BriefingStarted">
              <conditions>
                <check_any>
                  <event_briefing_started cue="$MissionCue"/>
                  <event_briefing_submission_selected cue="$MissionCue"/>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$RenderTarget" exact="event.param.{1}"/>
                <set_value name="$StartBriefingCutscene"/>
                <set_value name="$stationindex" exact="1"/>
                <debug_text text="'Briefing started'" chance="$DebugChance"/>
              </actions>
              <cues>
                <cue name="DisplayCutscene" onfail="cancel">
                  <conditions>
                    <check_value value="$StartBriefingCutscene?"/>
                  </conditions>
                  <actions>
                    <!--<create_presentation_cluster name="$CutsceneCluster" background="macro.cluster_black_wlight_bg_macro"/>-->
                    <!--create_presentation_cluster name="$CutsceneCluster"/-->
                    <create_presentation_cluster name="$CutsceneCluster" background="macro.cluster_black_wlight_bg_macro"/>
                    <find_zone name="$CutsceneZone" space="$CutsceneCluster"/>
                    <!-- If the player must salvage a ship -->
                    <!--set_value name="$BriefingCutsceneStarted"/>
                    <set_value name="$CutsceneObject" exact="$TargetObject" />
                    <set_value name="$CutsceneKey" exact="'OrbitParameterized'"/>
                    <play_cutscene key="$CutsceneKey" rendertarget="$RenderTarget">
                      <param name="targetobject" object="$CutsceneObject"/>
                      <param name="orbitdist" number="6"/>
                      <param name="orbitelevation" number="5"/>
                    </play_cutscene-->
                  </actions>
                </cue>
                <cue name="BriefingStopped">
                  <conditions>
                    <check_any>
                      <event_briefing_cancelled cue="$MissionCue"/>
                      <event_briefing_submission_unselected cue="$MissionCue"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="$BriefingCutsceneStarted?">
                      <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
                      <remove_value name="$BriefingCutsceneStarted"/>
                      <stop_cutscene key="$CutsceneKey"/>
                      <do_if value="$CutsceneCluster.exists">
                        <destroy_object object="$CutsceneCluster"/>
                      </do_if>
                    </do_if>
                    <do_if value="$HoloMap?">
                      <remove_holomap/>
                      <remove_value name="$HoloMap"/>
                    </do_if>
                    <debug_text text="'Briefing canceled'" chance="$DebugChance"/>
                    <reset_cue cue="BriefingStarted"/>
                  </actions>
                </cue>
              </cues>
            </cue>
            <!--This cue creates the mission itself, either from scratch or via an existing mission offer-->
            <cue name="MissionAccepted">
              <conditions>
                <event_cue_signalled/>
              </conditions>
              <actions>
                <do_if value="not $WithoutOffer">
                  <speak actor="$Client" line="$VoiceTable.$MissionAccepted" comment="(player accepted mission offer)" chance="if $VoiceTable.$MissionAccepted == 0 then 0 else 100"/>
                  <signal_cue_instantly cue="md.GenericMissions.PlotMissionInterrupted" param="table[$client = $Client, $line = $VoiceTable.$MissionAccepted]"/>
                </do_if>
                <debug_text text="'Mission accepted!'" chance="$DebugChance"/>
                <set_value name="stat.missions_accepted" operation="add"/>
                <set_value name="$StartStep" exact="1"/>
                <set_value name="$FindStep" exact="$StartStep"/>
                <do_if value="$WithoutOffer">
                  <!--$MissionCue may already be a mission cue passed in as a parameter-->
                  <do_if value="not $MissionCue.hasmission">
                    <do_if value="$MissionThread">
                      <create_mission cue="$MissionCue" missionthread="$MissionThread" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText"/>
                    </do_if>
                    <do_else>
                      <create_mission cue="$MissionCue" name="$TextTable.$missionname" description="$TextTable.$description" difficulty="$Difficulty" faction="$ClientOwner" type="$MissionType" reward="$RewardCr" rewardtext="$RewardText"/>
                    </do_else>
                  </do_if>
                  <update_mission cue="$MissionCue">
                    <briefing comment="duplicated, see CreateOffer!">
                      <objective step="$FindStep" action="objective.find" text="$TextTable.$objective_find"/>
                    </briefing>
                  </update_mission>
                </do_if>
                <do_else>
                  <!--Copy data from the offer, then remove it-->
                  <do_if value="$MissionThread">
                    <create_mission cue="$MissionCue" offercue="$MissionCue" missionthread="$MissionThread"/>
                  </do_if>
                  <do_else>
                    <create_mission cue="$MissionCue" offercue="$MissionCue"/>
                  </do_else>
                  <remove_offer cue="$MissionCue"/>
                  <cancel_cue cue="With_Offer"/>
                </do_else>
                <do_if value="$ReportSignalCue">
                  <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_ACCEPTED.clone"/>
                  <set_value name="$FeedbackData.$ID" exact="'$MISSION_ACCEPTED'"/>
                  <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="Mission accepted"/>
                  <signal_cue_instantly cue="$ReportSignalCue"/>
                </do_if>
                <signal_cue_instantly cue="md.GenericMissions.GenericAcceptLogbookEntry" param="[$TextTable.$missionname, $Client, $ClientOwner]"/>
              </actions>
              <cues>
                <cue name="ActivateImmediately" onfail="cancel">
                  <conditions>
                    <check_value value="not $MissionThread"/>
                  </conditions>
                  <actions>
                    <signal_cue cue="ActivateMission"/>
                  </actions>
                </cue>
                <cue name="ActivateOnCondition" onfail="cancel">
                  <conditions>
                    <check_value value="$MissionThread"/>
                  </conditions>
                  <actions>
                    <do_if value="$MissionThread.canactivatesubmission.{$MissionCue}">
                      <signal_cue cue="ActivateMission"/>
                      <cancel_cue cue="ActivateOnCondition"/>
                    </do_if>
                  </actions>
                  <cues>
                    <!--TODO @Owen add an event for when a submission has been removed from the thread-->
                    <cue name="CheckMissionThreadState" checkinterval="1s">
                      <conditions>
                        <check_value value="$MissionThread.canactivatesubmission.{$MissionCue}"/>
                      </conditions>
                      <actions>
                        <signal_cue cue="ActivateMission"/>
                        <cancel_cue cue="ActivateOnCondition"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>
                <cue name="ActivateMission">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <do_if value="$ReportActivateCue">
                      <signal_cue_instantly cue="$ReportActivateCue" param="this"/>
                      <set_value name="$TargetObjects" exact="this.$TargetObjects" comment="copy from (local)this-cue to global-cue"/>
                      <!-- The lockboxes were spawned just now, so we can add the contents to a table of items the player has to deliver -->
                      <set_value name="$DeliveryItems" exact="table[]"/>
                      <do_all exact="$TargetObjects.count" counter="$i">
                        <set_value name="$Lockbox" exact="$TargetObjects.{$i}"/>
                        <set_value name="$LockboxWares" exact="$Lockbox.wares.list"/>
                        <do_all exact="$LockboxWares.count" counter="$k">
                          <set_value name="$LockboxWare" exact="$LockboxWares.{$k}"/>
                          <set_value name="$DeliveryItems.{$LockboxWare}" operation="add" exact="$Lockbox.wares.{$LockboxWare}.count"/>
                        </do_all>
                      </do_all>
                      <!--Create a group for dropped objects for the case where the RML is reset due to the player flying away. We don't want to lose track of them.-->
                      <create_group groupname="$DroppedObjects"/>
                    </do_if>
                    <do_if value="$MissionDuration">
                      <update_mission cue="$MissionCue" endtime="player.age + $MissionDuration"/>
                    </do_if>
                    <set_value name="$StartStep" exact="1"/>
                    <set_value name="$DeliverStep" exact="3"/>
                  </actions>
                  <cues>
                    <cue name="ReachedLocation" instantiate="true" version="2">
                      <conditions>
                        <event_cue_signalled/>
                      </conditions>
                      <actions>
                        <!--Create a group for dropped objects for the case where the RML is reset due to the player flying away. We don't want to lose track of them.-->
                        <!--<create_group groupname="$DroppedObjects"/>-->
                      </actions>
                      <patch sinceversion="2" state="complete">
                        <debug_text text="'Removed old RML instance'" filter="savegame"/>
                      </patch>
                    </cue>
                    <cue name="ReachedLocation_2">
                      <cues>
                        <!-- Trigger the RML, which will check the win/lose conditions and report back -->
                        <cue name="FindObject_Ref_2" ref="md.RML_FindObject.FindObject">
                          <!-- always pass these -->
                          <param name="EndSignalCue" value="MissionEnded_2"/>
                          <param name="MissionCue" value="$MissionCue"/>
                          <param name="StartStep" value="$FindStep" comment="Briefing step to start the mission on"/>
                          <param name="UpdateBriefing" value="true" comment="Update the briefing objective step when the objective is updated"/>
                          <param name="DebugChance" value="$DebugChance"/>
                          <param name="Text_Objective_Find" value="$TextTable.$objective_find"/>
                          <param name="Text_Objective_Pickup" value="$TextTable.$objective_pickup"/>
                          <!-- mission-related parameters -->
                          <param name="TargetSector" value="$TargetSector"/>
                          <param name="TargetOffset" value="$TargetOffset"/>
                          <param name="TargetRadius" value="$TargetRadius"/>
                          <param name="TargetObjects" value="$TargetObjects"/>
                          <param name="DroppedObjects" value="$DroppedObjects"/>
                        </cue>
                        <!--In the case of RML_RetrieveItem ending, this may lead to calling RML_Deliver_Inventory instead of the mission actually ending-->
                        <cue name="MissionEnded_2">
                          <!-- Handle the end-feedback (usually originating from the RML used above) -->
                          <conditions>
                            <event_cue_signalled/>
                          </conditions>
                          <actions>
                            <!-- Failure case -->
                            <do_if value="this.$EndFeedbackValue" max="0">
                              <debug_text text="'This mission has failed. RML Feedback: ' + this.$EndFeedbackValue" chance="$DebugChance"/>
                              <set_value name="$Feedback" exact="'$RML_FAILED'"/>
                              <speak actor="$Client" line="$VoiceTable.$MissionFailed" comment="(failed mission)" chance="if $VoiceTable.$MissionFailed == 0 then 0 else 100"/>
                              <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, @this.$EndFeedbackText]"/>
                              <remove_mission cue="$MissionCue" type="failed" reason="@this.$EndFeedbackText"/>
                              <signal_cue cue="CleanUp"/>
                            </do_if>
                            <!-- Success case -->
                            <do_else>
                              <!--TODO: Partial success-->
                              <do_if value="$DeliveryNPC">
                                <signal_cue cue="DeliverItem"/>
                              </do_if>
                              <do_else>
                                <debug_text text="'This mission has ended. RML Feedback: ' + MissionEnded.$EndFeedbackValue" chance="$DebugChance"/>
                                <include_actions ref="MissionSuccessful"/>
                                <signal_cue cue="CleanUp"/>
                              </do_else>
                            </do_else>
                          </actions>
                        </cue>
                        <cue name="DeliverItem">
                          <conditions>
                            <event_cue_signalled/>
                          </conditions>
                          <actions>
                            <cancel_cue cue="DeliverNPCDestroyed_Early_Check"/>
                            <cancel_cue cue="DeliverStationDestroyed_Early_Check"/>
                          </actions>
                          <cues>
                            <cue name="DeliverInventory_RML_Ref" ref="md.RML_Deliver_Inventory.Deliver_Inventory">
                              <param name="EndSignalCue" value="Deliver_RML_Ended"/>
                              <param name="MissionCue" value="$MissionCue"/>
                              <param name="StartStep" value="$DeliverStep" comment="Briefing step to start the mission on"/>
                              <param name="UpdateBriefing" value="true" comment="Update the briefing objective step when the objective is updated"/>
                              <!--Delivery params-->
                              <param name="WaresTableParam" value="$DeliveryItems" comment="Table of ware amounts. Key = ware. Value = [$maxamount, $remainingamount]. Inventory wares only."/>
                              <param name="DeliveryNPC" value="$DeliveryNPC" comment="The NPC to which the items should be delivered."/>
                              <param name="DeliveryObject" value="$DeliveryObject" comment="The object on which to point to before the NPC is placed. Also used to create the interior with the below parameters"/>
                              <param name="ProgressBarText" value="{30004,1054}" comment="Text to be displayed next to the ware delivery progress bar e.g. ('Delivered')"/>
                              <param name="ConversationOptionText" value="$TextTable.$conversationoption"/>
                              <param name="ConversationTipText" value="$TextTable.$tooltip"/>
                              <!-- ************************************************************************************************************************************************************************ -->
                              <!-- NPC Placement and interior creation - See library for parameter details-->
                              <param name="PlaceNPC" value="$PlaceNPC"/>
                              <param name="PlacementTable" value="$PlacementTable"/>
                              <!-- Interior parameters. If either is provided, all must be valid. -->
                              <param name="DeliveryRoomMacro" value="$DeliveryRoomMacro" comment="The dynamic interior room the DeliveryNPC should be placed in, if not placed already"/>
                              <param name="DeliveryCorridorMacro" value="$DeliveryCorridorMacro" comment="The dynamic interior corridor leading to DeliveryRoomMacro"/>
                              <param name="DeliveryDoor" value="if $DeliveryDoors then $DeliveryDoors.random else null" comment="The possible dynamic interior doors used to connect the room and corridor. When defining a room or corridor macro, this is is the variable saved in the doors parameter"/>
                              <param name="DeliveryInteriorName" value="$DeliveryInteriorName" comment="The name of the dynamic interior the DeliveryNPC should used, if not placed already"/>
                              <!-- ************************************************************************************************************************************************************************ -->
                              <param name="DebugChance" value="$DebugChance"/>
                            </cue>
                          </cues>
                        </cue>
                        <cue name="Deliver_RML_Ended">
                          <conditions>
                            <event_cue_signalled/>
                          </conditions>
                          <actions>
                            <!-- Failure case -->
                            <do_if value="this.$EndFeedbackValue" max="0">
                              <debug_text text="'This mission has failed. RML Feedback: ' + this.$EndFeedbackValue" chance="$DebugChance"/>
                              <set_value name="$Feedback" exact="'$RML_FAILED'"/>
                              <speak actor="$Client" line="$VoiceTable.$MissionFailed" comment="(failed mission)" chance="if $VoiceTable.$MissionFailed == 0 then 0 else 100"/>
                              <signal_cue_instantly cue="md.GenericMissions.GenericFailLogbookEntry" param="[$TextTable.$missionname, $Client, @this.$EndFeedbackText]"/>
                              <remove_mission cue="$MissionCue" type="failed" reason="@this.$EndFeedbackText"/>
                              <signal_cue cue="CleanUp"/>
                            </do_if>
                            <!-- Success case -->
                            <do_else>
                              <debug_text text="'This mission has ended. RML Feedback: ' + this.$EndFeedbackValue" chance="$DebugChance"/>
                              <include_actions ref="MissionSuccessful"/>
                              <signal_cue cue="CleanUp"/>
                            </do_else>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                    <library name="MissionSuccessful">
                      <actions>
                        <do_if value="$RewardNotoriety and $ClientOwner">
                          <debug_text text="'Relation was: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                          <add_faction_relation faction="faction.player" otherfaction="$ClientOwner" value="$RewardNotoriety" reason="relationchangereason.missioncompleted"/>
                          <debug_text text="'Relation is now: ' + player.entity.relationto.{$ClientOwner}" chance="$DebugChance"/>
                        </do_if>
                        <do_if value="$RewardCr">
                          <reward_player money="$RewardCr"/>
                        </do_if>
                        <do_if value="$RewardObj">
                          <do_if value="$RewardObj.isinventory">
                            <add_inventory entity="player.entity" ware="$RewardObj"/>
                            <show_notification text="[{1015,100}, '', $RewardText]" sound="notification_achievement" comment="Item received"/>
                          </do_if>
                        </do_if>
                        <set_value name="stat.missions_completed" operation="add"/>
                        <set_value name="$Feedback" exact="'$MISSION_SUCCEEDED'"/>
                        <speak actor="$Client" line="$VoiceTable.$MissionSuccess" comment="(successful mission)" chance="if $VoiceTable.$MissionSuccess == 0 then 0 else 100"/>
                        <signal_cue_instantly cue="md.GenericMissions.GenericCompleteLogbookEntry" param="[$TextTable.$missionname, $Client, null, $RewardCr]"/>
                        <remove_mission cue="$MissionCue" type="completed" activate="next"/>
                      </actions>
                    </library>
                    <cue name="Aborted">
                      <conditions>
                        <event_mission_aborted cue="$MissionCue"/>
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericAbortLogbookEntry" param="[$TextTable.$missionname, $Client]"/>
                        <set_value name="$Feedback" exact="'$MISSION_ABORTED'"/>
                        <remove_mission cue="$MissionCue" type="aborted"/>
                        <signal_cue cue="CleanUp"/>
                      </actions>
                    </cue>
                    <cue name="MissionTimeout" onfail="cancel">
                      <conditions>
                        <check_value value="typeof $MissionDuration == datatype.time"/>
                        <check_value value="$MissionDuration" min="1s"/>
                      </conditions>
                      <delay exact="$MissionDuration"/>
                      <actions>
                        <signal_cue_instantly cue="md.GenericMissions.GenericTimeoutLogbookEntry" param="[$TextTable.$missionname, $Client]"/>
                        <remove_mission cue="$MissionCue" type="failed"/>
                        <set_value name="$Feedback" exact="'$MISSION_TIMEOUT'"/>
                        <signal_cue_instantly cue="CleanUp"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>
        <cue name="ForceCleanup" onfail="cancel">
          <conditions>
            <check_value value="$ForceCleanup"/>
          </conditions>
          <actions>
            <do_if value="not $ForceCleanup.exists">
              <set_value name="$Feedback" exact="'$INVALID_FORCE_CLEANUP'"/>
              <signal_cue_instantly cue="CleanUp"/>
            </do_if>
          </actions>
          <cues>
            <cue name="ForceCleanup_Wait">
              <conditions>
                <check_any>
                  <event_cue_completed cue="$ForceCleanup"/>
                  <check_all>
                    <event_cue_signalled cue="$ForceCleanup"/>
                    <check_value value="event.param == $MissionCue"/>
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <set_value name="$Feedback" exact="'$FORCED_CLEANUP'"/>
                <signal_cue_instantly cue="CleanUp"/>
              </actions>
            </cue>
          </cues>
        </cue>
        <cue name="CleanUp">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--Temp value. This is used to identify if a cutscene for this mission is still playing.-->
            <do_if value="$BriefingCutsceneStarted?">
              <remove_value name="$BriefingCutsceneStarted"/>
              <stop_cutscene key="$CutsceneKey"/>
              <do_if value="$CutsceneCluster.exists">
                <destroy_object object="$CutsceneCluster"/>
              </do_if>
              <do_if value="$CutsceneShip.exists">
                <destroy_object object="$CutsceneShip"/>
              </do_if>
            </do_if>
            <do_if value="$HoloMap?">
              <remove_holomap/>
              <remove_value name="$HoloMap"/>
            </do_if>
            <!--***Cleanup objects***-->
            <do_if value="$ReportActivateCue" comment="Crates spawned specifically for this mission, clean them up">
              <do_all exact="$TargetObjects.count" counter="$i">
                <debug_text text="'Cleanup ' + $TargetObjects.{$i} + '(' + $TargetObjects.{$i}.knownname + ')'" chance="$DebugChance"/>
                <destroy_object object="$TargetObjects.{$i}"/>
              </do_all>
            </do_if>
            <!--No .exists check here as $Client may not be connected to gamegraph-->
            <do_if value="$Client.isclass.npc and (not $PreexistingClient?)">
              <destroy_object object="$Client" comment="cleanup the client we created with create_cue_actor"/>
            </do_if>
            <!--***Evaluate result***-->
            <do_if value="$DebugChance or $ReportSignalCue">
              <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.{$Feedback}.clone"/>
              <do_if value="$FeedbackData">
                <set_value name="$FeedbackData.$ID" exact="$Feedback"/>
                <debug_text text="'Mission ended with reason: ' + $FeedbackData.$type + ' - ' + $FeedbackData.$text" chance="$DebugChance"/>
              </do_if>
              <do_else>
                <set_value name="$FeedbackData" exact="table[$ID = 'error_unknown', $type = 'error', $text = 'This is an unknown error']" comment="feedback = id, type and error-text from the above FeedbackValues-table"/>
                <assert value="false" text="'Mission ended with unknown case: ' + $Feedback + ' [Owen]'" break="1"/>
              </do_else>
              <do_if value="$ReportSignalCue" comment="The cue which called us">
                <set_value name="$ReportSignalCue.$EndFeedbackValue" exact="$FeedbackData" comment="return feedback-data to calling cue"/>
                <signal_cue cue="$ReportSignalCue"/>
              </do_if>
            </do_if>
            <cancel_cue cue="Start"/>
          </actions>
        </cue>
      </cues>
    </library>
    <!-- MISSION SETUP HELPERS -->
    <!-- input: $MissionLevel; output: $MissionLevel, $TargetRadius, $LockboxMacro -->
    <library name="ConfigureDifficulty">
      <actions>
        <set_value name="$MissionLevel" exact="if not $MissionLevel? then 1 else $MissionLevel"/>
        <debug_text text="'Missing $MissionLevel input. Set to: ' + $MissionLevel" chance="$DebugChance"/>
        <set_value name="$LevelVsLockboxMacro" exact="table[                            {  3 } = [ 10km, macro.sm_gen_lockbox_common_01_macro,    2 ],                            {  4 } = [ 15km, macro.sm_gen_lockbox_unusual_01_macro,   2 ],                            {  5 } = [ 20km, macro.sm_gen_lockbox_rare_01_macro,      2 ],                            {  7 } = [ 30km, macro.sm_gen_lockbox_explosive_01_macro, 1 ],                            { 10 } = [ 40km, macro.sm_gen_lockbox_special_01_macro,   1 ] ]"/>
        <set_value name="$Level" exact="$LevelVsLockboxMacro.keys.random"/>
        <set_value name="$TargetRadius" exact="$LevelVsLockboxMacro.{$Level}.{1}"/>
        <set_value name="$LockboxMacro" exact="$LevelVsLockboxMacro.{$Level}.{2}"/>
        <set_value name="$LockboxAmount" exact="$LevelVsLockboxMacro.{$Level}.{3}"/>
        <set_value name="$MissionLevel" exact="$MissionLevel + $Level - 1"/>
      </actions>
    </library>
    <!--  input: $LockboxAmount, output: $CrateContent -->
    <library name="Setup_SetupCrates_Normal">
      <actions>
        <set_value name="$CrateContent" exact="[                    [[ware.inv_majaglit, 4], [ware.inv_argnusteak, 7]]                    ]"/>
        <do_if value="$LockboxAmount gt 1">
          <append_to_list name="$CrateContent" exact="[[ware.inv_mixedfruit, 9]]"/>
        </do_if>
      </actions>
    </library>
    <library name="Setup_SetupCrates_TradeGoods">
      <actions>
        <set_value name="$CrateContent" exact="[                    [[[ware.inv_algaescrubber, ware.inv_rapidsandfilter, ware.inv_carbonfilter, ware.inv_herbicide, ware.inv_finemeal, ware.inv_interfaceunit].random, [1,2,3].random], [[ware.inv_bandages, ware.inv_needle].random, [2,3,4].random]]                    ]"/>
        <do_if value="$LockboxAmount gt 1">
          <append_to_list name="$CrateContent" exact="[[ware.inv_rarespices, [2,3,4].random]]"/>
        </do_if>
      </actions>
    </library>
    <library name="Setup_SetupCrates_Medical">
      <actions>
        <set_value name="$CrateContent" exact="[                    [[ware.inv_needle, 4], [ware.inv_bandages, 7]]                    ]"/>
        <do_if value="$LockboxAmount gt 1">
          <append_to_list name="$CrateContent" exact="[[ware.inv_sedative, 9]]"/>
        </do_if>
      </actions>
    </library>
    <library name="Setup_SetupCrates_Illegal">
      <actions>
        <set_value name="$CrateContent" exact="[                    [[ware.inv_agidevice_01, 4], [ware.inv_hallucinogenics, 7]]                    ]"/>
        <do_if value="$LockboxAmount gt 1">
          <append_to_list name="$CrateContent" exact="[[ware.inv_unstablecrystal, 9]]"/>
        </do_if>
      </actions>
    </library>
    <!-- input: -, output: $TargetOffset and $TargetSector -->
    <library name="Setup_SpawnLocation">
      <actions>
        <!-- Medium Difficulty Xenon Variant -->
        <!--TODO: Add Xenon specific text-->
        <find_sector_in_range name="$XenonSectors" object="player.entity" maxdistance="2" owner="[faction.xenon, faction.xenon1, faction.xenon2, faction.xenon3, faction.xenon4, faction.xenon5, faction.xenon6]" multiple="true"/>
        <do_if value="$XenonSectors.count" chance="40">
          <set_value name="$XenonSector" exact="$XenonSectors.random"/>
          <get_safe_pos result="$TargetOffset" sector="$XenonSector" min="30km" max="100" radius="45km" comment="45km just outside station range"/>
          <set_value name="$TargetOffset" exact="position.[$TargetOffset.x, 0, $TargetOffset.z]" comment="Engine limitation, keep it on ecliptic (y=0)"/>
          <set_value name="$TargetSector" exact="$XenonSector"/>
          <set_value name="$Difficulty" exact="level.medium"/>
          <set_value name="$Missionlevel" operation="add" exact="4"/>
        </do_if>
        <!-- Determine spawn position (Standard) -->
        <do_if value="not $TargetSector?">
          <create_position name="$TargetOffset" object="player.entity.object" space="player.sector" min="70km" max="120km"/>
          <set_value name="$TargetOffset" exact="position.[$TargetOffset.x, 0, $TargetOffset.z]" comment="Engine limitation, keep it on ecliptic (y=0)"/>
          <set_value name="$TargetSector" exact="player.sector"/>
        </do_if>
      </actions>
    </library>
    <!-- input: $Faction, output: $TargetOffset and $TargetSector -->
    <library name="Setup_DangerousSpawnLocation">
      <actions>
        <!-- Find the closest enemy sector -->
        <run_actions ref="md.LIB_Generic.FindNearestEnemySectorForFaction" result="$NearestEnemySector">
          <param name="Faction" value="$Faction"/>
        </run_actions>
        <do_if value="$NearestEnemySector">
          <set_value name="$TargetSector" exact="$NearestEnemySector"/>
        </do_if>
        <do_else>
          <!--fallback: No nearby enemy sector found. Choose a random nearby sector-->
          <find_sector_in_range name="$TargetSector" object="player.entity" maxdistance="3" multiple="false"/>
        </do_else>
        <!-- Find all friendly factions -->
        <set_value name="$FriendlyFactions" exact="null"/>
        <create_list name="this.$FriendlyFactions"/>
        <do_all exact="lookup.faction.count" counter="$i">
          <do_if value="not ( lookup.faction.{$i}.hasrelation.kill.{this.$Faction} or                               lookup.faction.{$i}.hasrelation.enemy.{this.$Faction} )">
            <append_to_list name="this.$FriendlyFactions" exact="lookup.faction.{$i}"/>
          </do_if>
        </do_all>
        <!-- Choose random gate in $NearestEnemySector which leads to a friendly sector -->
        <create_group groupname="$PotentialTargetGates"/>
        <find_object name="$EnemySectorGates" macro="macro.props_gates_anc_gate_macro" multiple="true" space="$TargetSector"/>
        <do_if value="$EnemySectorGates.count">
          <do_all exact="$EnemySectorGates.count" counter="$e">
            <do_all exact="$FriendlyFactions.count" counter="$f">
              <do_if value="$EnemySectorGates.{$e}.destination.sector.owner == $FriendlyFactions.{$f}">
                <add_to_group groupname="$PotentialTargetGates" object="$EnemySectorGates.{$e}"/>
              </do_if>
            </do_all>
          </do_all>
        </do_if>
        <do_else>
          <debug_text text="'Setup_DangerousSpawnLocation failed: No gates in $TargetSector (' + $TargetSector + ')'"/>
        </do_else>
        <do_if value="$PotentialTargetGates.count">
          <set_value name="$TargetGate" exact="$PotentialTargetGates.random"/>
        </do_if>
        <!-- If $NearestEnemySector has no gate to a friendly sector, choose a gate in $NearestEnemySector at random -->
        <do_else>
          <set_value name="$TargetGate" exact="$EnemySectorGates.random"/>
          <debug_text text="'No gate in $TargetSector (' + $TargetSector + ') leads to a friendly sector. Gate chosen randomly.'"/>
        </do_else>
        <!-- Determine spawn position close to selected gate -->
        <create_position name="$TargetOffset" object="$TargetGate" space="$TargetSector" min="10km" max="40km"/>
        <set_value name="$TargetOffset" exact="position.[$TargetOffset.x, 0, $TargetOffset.z]" comment="Engine limitation, keep it on ecliptic (y=0)"/>
        <!-- Remove temporaries -->
        <remove_value name="$NearestEnemySector"/>
        <remove_value name="$FriendlyFactions"/>
        <remove_value name="$EnemySectorGates"/>
        <remove_value name="$PotentialTargetGates"/>
        <remove_value name="$TargetGate"/>
      </actions>
    </library>
    <library name="Setup_SpawnCrates_Call" purpose="run_actions">
      <params>
        <param name="CrateContent"/>
        <param name="TargetSector"/>
        <param name="TargetOffset"/>
        <param name="AllowYAxis" default="false"/>
        <param name="TargetRadius"/>
        <param name="LockboxMacro" default="macro.sm_gen_lockbox_rare_01_macro"/>
        <param name="MinHull" default="null" comment="For story purposes"/>
        <param name="DebugChance" default="0"/>
      </params>
      <actions>
        <include_actions ref="Setup_SpawnCrates"/>
        <do_if value="MinHull?">
          <do_for_each in="$TargetObjects" name="$CurrentCrate">
            <set_object_min_hull object="$MinHull" exact="20"/>
          </do_for_each>
        </do_if>
        <return value="this.$TargetObjects"/>
      </actions>
    </library>
    <!-- output: $TargetObjects, input: $CrateContent of [[ware.xxx, count], ...], $TargetOffset, $TargetRadius -->
    <library name="Setup_SpawnCrates">
      <actions>
        <!-- Create the lockboxes and fill them -->
        <create_group groupname="$TargetObjects"/>
        <do_all exact="$CrateContent.count" counter="$Counter">
          <set_value name="$Pitch" min="0" max="360"/>
          <set_value name="$Yaw" min="0" max="360"/>
          <set_value name="$Roll" min="0" max="360"/>
          <do_if value="not $LockboxMacro?">
            <set_value name="$LockboxMacro" exact="macro.sm_gen_lockbox_rare_01_macro"/>
          </do_if>
          <do_if value="$AllowYAxis? and $AllowYAxis">
            <create_lockbox name="$Crate" macro="$LockboxMacro" sector="$TargetSector">
              <safepos value="$TargetOffset" min="0" max="$TargetRadius" allowyaxis="true"/>
              <rotation pitch="($Pitch)deg" yaw="($Yaw)deg" roll="($Roll)deg"/>
            </create_lockbox>
          </do_if>
          <do_else>
            <create_lockbox name="$Crate" macro="$LockboxMacro" sector="$TargetSector">
              <safepos value="$TargetOffset" min="0" max="$TargetRadius" allowyaxis="false"/>
              <rotation pitch="($Pitch)deg" yaw="($Yaw)deg" roll="($Roll)deg"/>
            </create_lockbox>
          </do_else>
          <do_all exact="$CrateContent.{$Counter}.count" counter="$Ware_Counter">
            <add_cargo object="$Crate" ware="$CrateContent.{$Counter}.{$Ware_Counter}.{1}" exact="$CrateContent.{$Counter}.{$Ware_Counter}.{2}"/>
            <debug_text text="'GM_Find_Object: ' + $CrateContent.{$Counter}.{$Ware_Counter}.{2} + ' ' + $CrateContent.{$Counter}.{$Ware_Counter}.{1} + ' added to $Crate ' + $Counter + '.'" chance="$DebugChance"/>
          </do_all>
          <add_to_group groupname="$TargetObjects" object="$Crate"/>
        </do_all>
        <debug_text text="'Spawn ' + $Crate + '(' + $Crate.knownname + ')'" chance="$DebugChance"/>
      </actions>
    </library>
    <!--GENERIC MISSION VARIANTS-->
    <cue name="Force_Generic_Var_1" instantiate="true">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <signal_cue cue="md.GenericMissions.RemoveAllOffers"/>
        <do_all exact="30">
          <signal_cue_instantly cue="GenerateGenericMission" param="table[$Sector = player.sector, $MissionVariant = 1, $DebugChance = 100]"/>
        </do_all>
      </actions>
      <force name="GM_Find_Object_Var_1"/>
    </cue>
    <!--event.param = table[
    $Sector,
    $ReportSignalCue (Optional. Cue to be signalled when something happens which could be of interest to the calling cue. Saves values to ReportSignalCue.$FeedbackValue and ReportSignalCue.$EndFeedbackValue)
    $MissionVariant (Optional),
    $RemoveOnSectorChange (Optional, defaults to true)
    $DebugChance (Optional)]-->
    <cue name="GenerateGenericMission" instantiate="true" namespace="this" version="2">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        <set_value name="$Sector" exact="event.param.$Sector"/>
        <set_value name="$ReportSignalCue" exact="@event.param.$ReportSignalCue"/>
        <set_value name="$MissionVariant" exact="@event.param.$MissionVariant"/>
        <do_if value="event.param.$RemoveOnSectorChange?">
          <set_value name="$RemoveOnSectorChange" exact="event.param.$RemoveOnSectorChange"/>
        </do_if>
        <do_else>
          <set_value name="$RemoveOnSectorChange" exact="true"/>
        </do_else>
        <set_value name="$DebugChance" exact="@event.param.$DebugChance"/>
        <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>
        <set_value name="$FeedbackManager" exact="FeedbackValueManager"/>
        <assert value="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT?" text="'Required error code does not exist. Was the FeedbackValueManager not updated for stand-alone missions? [Owen/Roger]'"/>
        <debug_text text="'Attempting to generate a generic mission'" chance="$DebugChance"/>
      </actions>
      <patch sinceversion="2" state="complete">
        <do_if value="$ReportSignalCue.exists">
          <set_value name="$ReportSignalCue.$GM_Wrapper" exact="this"/>
        </do_if>
        <do_else>
          <debug_text text="'cancelling dead GM instance'" filter="savegame"/>
          <cancel_cue cue="this"/>
        </do_else>
      </patch>
      <cues>
        <cue name="GenerateGenericMission_SelectVariant">
          <actions>
            <set_value name="$ValidVariants" exact="[]"/>
            <!--Set up some common variables first so that the variants don't have to do things multiple times-->
            <!--Find potential offer stations in the sector-->
            <find_station name="$PotentialOfferStations" excluded="md.GenericMissions.Manager.$ExcludedOfferObjects" space="$Sector" multiple="true">
              <match owner="md.GenericMissions.Manager.$DefaultExcludedOfferFactions" negate="true"/>
              <match_relation_to object="player.entity" comparison="not" relation="enemy"/>
            </find_station>
            <do_if value="$PotentialOfferStations.count">
              <do_if value="$MissionVariant">
                <!--A specific MissionVariant ID was requested-->
                <debug_text text="'Checking if requested ' + $MissionVariant + ' can be spawned'" chance="$DebugChance"/>
                <do_if value="$MissionVariant == 1">
                  <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
                </do_if>
                <do_else>
                  <assert value="false" text="'Unknown $MissionVariant ID ' + $MissionVariant + ' [Owen]'"/>
                </do_else>
              </do_if>
              <do_else>
                <!--Attempt to a mission variant at random-->
                <signal_cue_instantly cue="GenerateGenericMission_Variant_1"/>
              </do_else>
            </do_if>
            <do_if value="$ValidVariants.count">
              <signal_cue cue="$ValidVariants.random"/>
            </do_if>
            <do_else>
              <do_if value="$ReportSignalCue">
                <set_value name="$FeedbackData" exact="$FeedbackManager.$FeedbackValues.$MISSION_NO_VARIANT.clone"/>
                <set_value name="$FeedbackData.$ID" exact="'$MISSION_NO_VARIANT'"/>
                <set_value name="$ReportSignalCue.$FeedbackValue" exact="$FeedbackData.clone" comment="No mission variant possible"/>
                <signal_cue_instantly cue="$ReportSignalCue"/>
              </do_if>
              <cancel_cue cue="GenerateGenericMission"/>
            </do_else>
          </actions>
        </cue>
        <!-- Find Lockbox, collect content, deliver content to NPC -->
        <cue name="GenerateGenericMission_Variant_1" namespace="this">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <!--this uses its own namespace so grab the shared data from GenerateGenericMission-->
            <set_value name="$Sector" exact="GenerateGenericMission.$Sector"/>
            <set_value name="$DebugChance" exact="GenerateGenericMission.$DebugChance"/>
            <set_value name="$OfferStations" exact="GenerateGenericMission.$PotentialOfferStations.clone"/>
            <shuffle_list list="$OfferStations"/>
            <set_value name="$Valid" exact="false"/>
            <set_value name="$Station" exact="$OfferStations.random"/>
            <set_value name="$Faction" exact="$Station.owner"/>
            <set_value name="$DeliveryStation" exact="null"/>
            <set_value name="$Difficulty" exact="level.easy"/>
            <set_value name="$MissionLevel" exact="1"/>
            <include_actions ref="ConfigureDifficulty" comment="input: $MissionLevel; output: $MissionLevel, $TargetRadius, $LockboxMacro"/>
            <set_value name="$DeliveryStep" exact="true"/>
            <do_any>
              <!-- With Delivery -->
              <do_all>
                <do_if value="md.$DLCBoronFactions.indexof.{$Faction}" chance="60">
                  <!-- Boron Crate Delivery -->
                  <set_value name="$TextOffset" exact="5000"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_if>
                <do_if value="md.$SplitFactions.indexof.{$Faction}" chance="60">
                  <!-- Split Crate Delivery -->
                  <set_value name="$TextOffset" exact="1400"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_if>
                <do_if value="md.$TerranEarthFactions.indexof.{$Faction}" chance="60">
                  <!-- Protectorate Crate Delivery -->
                  <set_value name="$TextOffset" exact="1600"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_if>
                <do_else>
                  <set_value name="$TextOffset" exact="1000"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.generic]"/>
                </do_else>
                <include_actions ref="Setup_SetupCrates_Normal"/>
                <include_actions ref="Setup_SpawnLocation"/>
              </do_all>
              <do_all>
                <do_if value="md.$DLCBoronFactions.indexof.{$Faction}" chance="40">
                  <!-- Boron Medical Delivery -->
                  <set_value name="$TextOffset" exact="[5100, 5200].random"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_if>
                <do_if value="md.$SplitFactions.indexof.{$Faction}" chance="40">
                  <!-- Split Medical Delivery -->
                  <set_value name="$TextOffset" exact="1500"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.shady]"/>
                </do_if>
                <do_if value="md.$TerranFactions.indexof.{$Faction}" chance="40">
                  <!-- Terran Crate Delivery -->
                  <set_value name="$TextOffset" exact="1700"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_if>
                <do_else>
                  <set_value name="$TextOffset" exact="1100"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.crewquarters]"/>
                </do_else>
                <include_actions ref="Setup_SetupCrates_Medical"/>
                <include_actions ref="Setup_SpawnLocation"/>
              </do_all>
              <do_all>
                <do_if value="md.$SplitFactions.indexof.{$Faction}" chance="40">
                  <!-- Split Medical Delivery -->
                  <set_value name="$TextOffset" exact="1500"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.shady]"/>
                </do_if>
                <do_else>
                  <set_value name="$TextOffset" exact="1200"/>
                  <set_value name="$DeliveryRoomTags" exact="[tag.livingroom, tag.generic]"/>
                </do_else>
                <include_actions ref="Setup_SetupCrates_Medical"/>
                <include_actions ref="Setup_SpawnLocation"/>
              </do_all>
              <do_all>
                <set_value name="$TextOffset" exact="1300"/>
                <set_value name="$DeliveryRoomTags" exact="[tag.bar]"/>
                <include_actions ref="Setup_SetupCrates_Normal"/>
                <include_actions ref="Setup_SpawnLocation"/>
              </do_all>
              <!-- Without Delivery -->
              <do_all>
                <set_value name="$TextOffset" exact="3000"/>
                <set_value name="$LockboxMacro" exact="macro.sm_gen_lockbox_explosive_01_macro"/>
                <!-- TODO: Make the mission succeed if the boxes blow up -->
                <!-- TODO: Maybe give the lockbox a chance to contain mines: hidden_trap_lockbox, hidden_trap2_lockbox-->
                <include_actions ref="Setup_SetupCrates_TradeGoods"/>
                <include_actions ref="Setup_SpawnLocation"/>
                <set_value name="$DeliveryStep" exact="false"/>
              </do_all>
            </do_any>
            <do_if value="$CrateContent">
              <set_value name="$Valid" exact="true" comment="crates spawned in postinit"/>
            </do_if>
            <do_if value="$Valid">
              <append_to_list name="GenerateGenericMission.$ValidVariants" exact="this"/>
            </do_if>
            <do_else>
              <cancel_cue cue="this"/>
            </do_else>
          </actions>
          <cues>
            <cue name="GenerateGenericMission_Variant_1_Trigger">
              <conditions>
                <event_cue_signalled cue="parent"/>
              </conditions>
              <actions>
                <do_if value="$DeliveryStep == true">
                  <!-- Create a room and NPC for the delivery step  -->
                  <set_value name="$DeliveryStation" exact="$Station"/>
                  <do_if value="not @$DeliveryRoomTags.count">
                    <set_value name="$DeliveryRoomTags" exact="[tag.bar]"/>
                  </do_if>
                  <get_room_definition macro="$DeliveryRoomMacro" tags="$DeliveryRoomTags" race="$DeliveryStation.trueowner.primaryrace"/>
                  <run_actions ref="md.LIB_Generic.DetermineCorridorForRoom" result="$CorridorDefinition">
                    <param name="RoomMacro" value="$DeliveryRoomMacro"/>
                    <param name="Race" value="$DeliveryStation.trueowner.primaryrace"/>
                  </run_actions>
                  <set_value name="$DeliveryCorridorMacro" exact="$CorridorDefinition.{1}"/>
                  <set_value name="$DeliveryDoors" exact="$CorridorDefinition.{2}"/>
                  <do_if value="$DeliveryCorridorMacro and $DeliveryRoomMacro">
                    <set_value name="$DeliveryInteriorName" exact="$DeliveryRoomMacro.name"/>
                  </do_if>
                  <create_cue_actor cue="GenerateGenericMission_Variant_1_Trigger" name="$MissionActor">
                    <select faction="$Faction"/>
                    <owner exact="$Faction"/>
                  </create_cue_actor>
                  <set_entity_traits entity="$MissionActor" missionactor="true" customhandler="true"/>
                  <set_entity_type entity="$MissionActor" type="entitytype.crowd"/>
                  <set_value name="$Client" exact="$MissionActor"/>
                </do_if>
                <create_group groupname="$TargetObjects" comment="empty group, filled in postinit"/>
              </actions>
              <cues>
                <cue name="GenerateGenericMission_Variant_1_Ref" ref="Start">
                  <param name="OfferObject" value="$Station"/>
                  <param name="Client" value="@$Client"/>
                  <param name="MissionLevel" value="$MissionLevel"/>
                  <param name="Difficulty" value="$Difficulty"/>
                  <!--Mission offer-->
                  <param name="RemoveOnSectorChange" value="@GenerateGenericMission.$RemoveOnSectorChange"/>
                  <param name="BBSSpace" value="$Sector"/>
                  <!--Mission text-->
                  <param name="Page" value="30149"/>
                  <param name="TextOffset" value="$TextOffset"/>
                  <!--Mission specific params-->
                  <param name="Faction" value="$Faction"/>
                  <param name="TargetSector" value="$TargetSector"/>
                  <param name="TargetOffset" value="$TargetOffset"/>
                  <param name="TargetRadius" value="$TargetRadius"/>
                  <param name="TargetObjects" value="$TargetObjects"/>
                  <!--See library for parameter details-->
                  <param name="DeliveryNPC" value="@$MissionActor" comment="The NPC to which the items should be delivered. If null, the mission ends on collecting the ware (primarily for legacy mission support)"/>
                  <param name="PlaceNPC" value="$DeliveryStep" comment="Does the mission handle the placement and removal of the delivery NPC? If false, some other system must be in charge of doing so."/>
                  <param name="DeliveryObject" value="@$DeliveryStation"/>
                  <param name="DeliveryRoomMacro" value="@$DeliveryRoomMacro"/>
                  <param name="DeliveryCorridorMacro" value="@$DeliveryCorridorMacro"/>
                  <param name="DeliveryDoors" value="@$DeliveryDoors"/>
                  <param name="DeliveryInteriorName" value="@$DeliveryInteriorName"/>
                  <param name="ReportActivateCue" value="GenerateGenericMission_Variant_1_PostInit"/>
                  <param name="ReportSignalCue" value="@GenerateGenericMission.$ReportSignalCue"/>
                  <param name="DebugChance" value="@GenerateGenericMission.$DebugChance"/>
                </cue>
                <!-- Use a callback, so we don't spam the entire universe with loads of objects -->
                <cue name="GenerateGenericMission_Variant_1_PostInit">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <include_actions ref="md.GM_FindObject.Setup_SpawnCrates" comment="returns $TargetObjects"/>
                    <set_value name="event.param.$TargetObjects" exact="$TargetObjects"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>
      </cues>
    </cue>
  </cues>
</mdscript>
